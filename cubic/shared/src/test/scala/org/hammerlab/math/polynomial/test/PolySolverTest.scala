package org.hammerlab.math.polynomial.test

import hammerlab.indent.implicits.spaces4
import hammerlab.iterator._
import hammerlab.lines._
import hammerlab.math.FromDouble
import hammerlab.show._
import org.hammerlab.Suite
import org.hammerlab.io.print.Limit
import org.hammerlab.math.format.SigFigs
import org.hammerlab.math.polynomial
import org.hammerlab.math.polynomial.result.{ Expected, ResultGroup, Results, Stats, Zeros }
import org.hammerlab.math.polynomial.roots.RootShapes
import org.hammerlab.math.polynomial.{ ImaginaryRootPair, Real, TestCase, result }
import org.hammerlab.math.syntax.Doubleish._
import org.hammerlab.math.syntax.{ Doubleish, E }
import org.hammerlab.test.CanEq
import org.scalatest.exceptions.TestFailedException
import shapeless.HNil
import spire.algebra.{ Field, IsReal, NRoot, Signed, Trig }
import spire.math.{ Complex, abs }

import scala.math.exp
import scala.util.Random._

trait ShowD[D] {
  /**
   * For pretty-printing purposes, display [[D]]s as corresponding [[Double]] values
   */
  implicit def showD(implicit db: Doubleish[D], sd: Show[Double]): Show[D] =
    Show { _.toDouble.show }
}

abstract class PolySolverTest[T : Ordering : FromDouble : Field : IsReal : NRoot : Signed : Trig : Doubleish](degree: Int)
  extends Suite
    with ShowD[T] {

  /** Pretty-printing level */
  implicit var sigfigs: SigFigs = 3

  implicit def showDouble: Show[Double] = org.hammerlab.math.format.SigFigs.showSigFigs

  type D = T

  /** Check all polynomials whose roots are comprised of integers in the range [-[[M]], [[M]]], via [[rootSweep]] */
  val M: Int

  val N = degree

  /**
   * Subclasses implement solving for roots of a [[TestCase]] here
   */
  implicit def solve(t: TestCase[D]): Seq[Complex[D]]

  /**
   * Expected statistics about [[solve]]'s performance against ground-truth on [[TestCase]]s generated by sweeping roots
   * over integers in the range [-[[M]], [[M]]] (via [[rootSweep]])
   */

  def expecteds: Map[(Int, RootShapes), Expected] = Map.empty

  def sweepTests(M: Int,
                 expecteds: Map[(Int, RootShapes), Expected]): Unit = {
    val cases = rootSweep(M).toList
    val n = cases.size
    cases
      .groupBy {
        case TestCase(reals, imags, _, _) ⇒
          val max =
            (
              reals
                .map(_._1.t) ++
              imags
                .map(_._1)
                .flatMap(ip ⇒ Seq(ip.a, ip.b))
            )
            .map(abs(_))
            .max
            .toInt

          val shapes =
            RootShapes(
              reals.map(_._2),
              imags.map(_._2)
            )

          shapes
          //(max, shapes)
      }
      .toVector
      .sortBy(_._1)
      .foreach {
        case (
          (
//            max,
            shapes
          ),
          cases
        ) ⇒
          /*test(show"integer-roots sweep: max $max, root-shapes: $shapes")*/ {
            val results = Results(cases.iterator)
            val actual: Expected = results

            def print(): Unit = {
              println(
                show"$shapes:\t${actual.abs} ${actual.ratio}"
                //show"$max $shapes: ${actual.abs} ${actual.ratio}"
              )
/*
              println(
                Seq(
                  actual.abs,
                  actual.ratio
                )
                .join(",")
                .indent
                .show
              )
*/
            }

            print()

            //val expected = expecteds((max, shapes))
//            expecteds
//              .get(
//                (
//                  max,
//                  shapes
//                )
//              )
//              .foreach {
//                expected ⇒
//                  print()
/*
                  try {
                    implicit val ε: E = 1e-3
                    ===(actual, expected)
                  } catch {
                    case e: TestFailedException ⇒
                      print()
                      throw e
                  }
*/
//              }
          }
      }
  }

  /**
   * Expected statistics about [[solve]]'s performance against ground-truth on [[TestCase]]s with randomly-generated
   * roots (via [[randomCases]])
   */
  def random: Expected
  test("uniform random roots") {
    check(
      randomCases(rnd),
      random
    )
  }

  def logNormalRandom: Expected
  test("log-normal random roots") {
    check(
      randomCases(logNormal),
      logNormalRandom
    )
  }

  /**
   * Convenience-constructor for [[Expected]] instances containing expected values
   */
  def expected(absStats: Stats,
               ratioStats: Stats,
               worst: ResultGroup*): Expected =
    Expected(
      absStats,
      ratioStats,
      worst
    )

  implicit val limit: Limit = 3

  type Real    = polynomial.Real[D]
  type Result = result.Result[D]
  type Results = result.Results[D]
  type ResultGroup = result.ResultGroup[D]
  type Expected = result.Expected[D]

  /**
   * Run a polynomial-solver on some [[TestCase]]s, compute [[Results]] statistics about the solver's error relative to
   * the true roots, and verify them against provided/expected values
   *
   * @param cases test-cases to run
   */
  def check(cases: Iterator[TestCase[D]],
            expected: Expected): Unit = {
    val results = Results(cases)
    val actual: Expected = results //Results(cases)

    if (results.zeros.nonEmpty) {
      results.results.foreach {
        case rg @ ResultGroup(r, n) if r.zeros.nonEmpty ⇒
          println(rg.showLines)
        case _ ⇒
      }
    }

    println(
      Lines(
        show" Absolute-error statistics: ${actual.abs}",
        show"Log-ratio-error statistics: ${actual.ratio}",
        s"Worst cases:",
        indent(
          actual.worst
        )
      )
      .showLines
    )

    {
      /** check (and output) error-statistics to 2-3 digits' accuracy */
      implicit val ε: E = 1e-2

      /**
       * skip comparing the [[result.Expected.worst]] entries, since tests aren't populating "expected" values for
       * them atm
       */
      try {
        ===(actual, expected)
      } catch {
        case e: TestFailedException ⇒
          import Lines.LineJoinOps
          import generic._
          println(
            Seq(
              actual.abs,
              actual.ratio
            )
            .join(",")
            .show
          )
          throw e
      }
    }
  }

  implicit val resultsCanEqExpected: CanEq[Results, Expected] =
    new CanEq[Results, Expected] {
      import org.hammerlab.test.CanEq.Cmp
      import shapeless.::
      type L = Stats :: Stats :: Zeros :: HNil
      val cmpList = shapeless.the[Cmp[L]]
      override type Error = cmpList.Error
      override def cmp(l: Results, r: Expected): Option[Error] = {
        implicit def toList(e: Expected): L = e.abs :: e.ratio :: e.zeros :: HNil
        cmpList(l: Expected, r)
      }
    }

  /** Helpers for converting to [[D]] */
  val fromD = FromDouble[D] _
  implicit val fromInt   : Int    ⇒ D = (x: Int) ⇒ fromD(x)
  implicit val fromDouble: Double ⇒ D = fromD

  /**
   * All distinct imaginary-root pairs with integral coefficients in the range [-M,M]
   */
  lazy val allImaginaryRootPairs =
    for {
      a ← -M to M
      b ←  1 to M
    } yield
      ImaginaryRootPair[D](a, b)

  val C = hammerlab.math.binomial

  def numRoots(roots: Int, options: Int) = C(options + roots - 1, roots)

  lazy val numImagPairs = allImaginaryRootPairs.size

  lazy val rootSweepSize =
    (
      for {
        numPairs ← 0 to N/2
        numReals = N - 2*numPairs
      } yield
        numRoots(numPairs, numImagPairs) * numRoots(numReals, 2*M + 1)
    )
    .sum

  /**
   * Iterate over the available imaginary-root conjugate-pairs (with integral real and imaginary parts in [-M, M], per
   * [[allImaginaryRootPairs]]), emitting all possible multi-sets of size `num`, and allowing repeats of individual
   * pairs (representing multiple roots)
   */
  def imaginaryRootPairs(num: Int) =
    allImaginaryRootPairs
      .unorderedSubsetsWithReplacement(num)

  /**
   * Iterator over all sets of `num` integer-roots in the range [-M,M] (including double/triple/quadruple roots)
   */
  def realRootsIter(num: Int): Iterator[List[(Real, Int)]] =
    (-M to M)
      .unorderedSubsetsWithReplacement(num)
      .map {
        _.map {
          case (value, arity) ⇒
            Real(value: D) → arity
        }
      }

  /**
   * Generate roots and corresponding coefficients for all possible mixtures of real/imaginary roots with coefficients
   * in [-M,m]
   */
  def rootSweep(M: Int = M): Iterator[TestCase[D]] =
    printEveryN(
      for {
        numImaginaryRootPairs ← (0 to N/2).iterator
        numImaginaryRoots = 2 * numImaginaryRootPairs

        numRealRoots = N - numImaginaryRoots
        reals ← realRootsIter(numRealRoots)

        imags ← imaginaryRootPairs(numImaginaryRootPairs)
      } yield
        TestCase[D](
          reals,
          imags,
          1
        )
    )

  def rnd(): D = nextGaussian()

  def logNormal(): D =
    exp(
      nextGaussian()
    ) *
    (
      if (nextBoolean())
         1
      else
        -1
    )

  val casePrintInterval = 1000

  /**
   * Helper for printing status messages while potentially brute-forcing many polynomial-solving iterations, e.g. via
   * [[randomCases]] or [[rootSweep]]
   */
  def printEveryN[T: Show](it: Iterator[TestCase[T]]): Iterator[TestCase[T]] =
    it
      .zipWithIndex
      .map {
        case (d, idx) ⇒
          if (idx % casePrintInterval == 0)
            println(show"iteration $idx:\t$d")
          d
      }

  /**
   * Test this many random roots-values for each overall "shape" (number and multiplicity of real and imaginary roots)
   */
  def iterationsPerRootShape: Int

  /**
   * Generate [[iterationsPerRootShape]] [[TestCase]]s – root-sets of polynomials of degree [[N]], along with derived
   * coefficients – for each possible roots-"shape" ({number of imaginary-root-pairs} X {multiplicity of real and
   * imaginary roots}).
   *
   * The free variables (values of real roots, and real and imaginary parts for imaginary-root-pairs, and a "scale" to
   * multiply all coefficients by) sampled from a standard normal distribution.
   */
  def randomCases(rnd: () => D): Iterator[TestCase[D]] = {
    scala.util.Random.setSeed(123)
    printEveryN(
      for {
        numImagPairs ← (0 to N/2).iterator
        numImagRoots = 2 * numImagPairs
        imagPairArities ← numImagPairs.unorderedPartitions

        numRealRoots = N - numImagRoots
        realArities ← numRealRoots.unorderedPartitions

        // do 10 reps with each possible arity-distribution of [imaginary X real] roots
        _ ← 1 to iterationsPerRootShape

        reals = realArities.map(Real(rnd()) → _)

        imags = imagPairArities.map(ImaginaryRootPair(rnd(), abs(rnd())) → _)

//        scale ← (1 to scalesPerIteration).map(_ ⇒ rnd())
        scale = rnd()
      } yield
        TestCase(
          reals,
          imags,
          scale
        )
    )
  }
}
